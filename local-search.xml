<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>可调用对象</title>
    <link href="/2022/02/24/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/02/24/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>C++中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类，本文对其进行归纳介绍</strong></p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ol><li><p>lambda表达式形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">[capture list](parameter list) -&gt; <span class="hljs-keyword">return</span> type &#123;function body&#125;<br></code></pre></td></tr></table></figure><p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。</p><ul><li>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void;</li><li>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和全局变量；</li><li>当定义一个lambda时，编译器生成一个与lambda对应的新的类类型。</li></ul></li><li><p>隐式捕获：</p><p>当我们混合使用隐式捕获和显示捕获时，需遵守:</p><ul><li>捕获列表中的第一个元素必须是一个&amp;或&#x3D;，此符号制定了默认捕获方式为引用或值；</li><li>显示捕获的变量必须使用与隐式捕获不同的方式。   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//os隐式捕获，引用捕获方式；c显示捕获，值捕获方式</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <br>        [&amp;, c](<span class="hljs-type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);<br><span class="hljs-comment">//os显示捕获，引用捕获方式，c饮食捕获，值捕获方式</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>        [=, &amp;os](<span class="hljs-type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>可变lambda</p><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改改变一个被捕获变量的值，就必须在参数列表首加上关键字mutable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> f = [v1]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> ++v1;  &#125;;<br>    v1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//j = 43;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是一个非const类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> f2 = [&amp;v1] &#123; <span class="hljs-keyword">return</span> ++v1;&#125;;<br>    v1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f2</span>();   <span class="hljs-comment">//j = 1;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="重载了函数调用运算符的类"><a href="#重载了函数调用运算符的类" class="headerlink" title="重载了函数调用运算符的类"></a>重载了函数调用运算符的类</h1><p>如果类定义了调用运算符，则该类的对象称作函数对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">absInt</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span>? -val: val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">-42</span>;<br>absInt absObj;<br><span class="hljs-type">int</span> ui = <span class="hljs-built_in">absObj</span>(i);<br></code></pre></td></tr></table></figure><h1 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h1><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行明明操作的调用运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">plus&lt;<span class="hljs-type">int</span>&gt; intAdd;   <span class="hljs-comment">//可执行int加法的函数对</span><br>negate&lt;<span class="hljs-type">int</span>&gt; intNegate;  <span class="hljs-comment">//可对int值取反的函数对</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)    <span class="hljs-comment">//  sum = 30</span><br>sum = <span class="hljs-built_in">intNegate</span>(<span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// sum = -30;</span><br>sum = <span class="hljs-built_in">intAdd</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">intNegate</span>(<span class="hljs-number">10</span>));    <span class="hljs-comment">//  sum = 0;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Http相关知识</title>
    <link href="/2022/02/14/Blog4/"/>
    <url>/2022/02/14/Blog4/</url>
    
    <content type="html"><![CDATA[<h1 id="Http和Https"><a href="#Http和Https" class="headerlink" title="Http和Https"></a>Http和Https</h1><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ol><li>HTTP协议传输的数据都是未加密的，传输隐私信息不安全。<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP安全。</li><li>HTTP + 加密 + 认证 + 完整性保护 &#x3D;   HTTPS</li><li>HTTPS使用混合加密机制。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</li></ol><h2 id="HTTPS连接流程"><a href="#HTTPS连接流程" class="headerlink" title="HTTPS连接流程"></a>HTTPS连接流程</h2><ol><li>客户端向服务器端发起SSL连接请求；</li><li>服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥;</li><li>客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 ;</li><li>服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密</li><li>进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密.</li></ol><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误</td><td>服务器处理请求出错</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的四种类型转换运算符</title>
    <link href="/2022/02/13/Blog/"/>
    <url>/2022/02/13/Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的四种类型转换运算符"><a href="#C-的四种类型转换运算符" class="headerlink" title="C++的四种类型转换运算符"></a>C++的四种类型转换运算符</h1><h2 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1.  static_cast"></a>1.  static_cast</h2><p>   任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast,没有运行时类型检测来保证转换的安全性，主要有以下几种用法：</p><ol><li><p>用于类层次结构中基类和子类之间指针或引用的转换</p><ul><li><p>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</p></li><li><p>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p></li></ul></li><li><p>基本数据类型之间的转换</p></li></ol><h2 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2.   const_cast"></a>2.   const_cast</h2><ol><li>const_cast只能改变运算对象的底层const</li><li>如果对象是一个常量，使用const_cast执行写操作会产生未定义的后果</li></ol><h2 id="3-reinterpret-cast"><a href="#3-reinterpret-cast" class="headerlink" title="3.   reinterpret_cast"></a>3.   reinterpret_cast</h2><p>通常为运算对象的位模式提供较低层次上的重新解释</p><h2 id="4-dynamic-cast"><a href="#4-dynamic-cast" class="headerlink" title="4.   dynamic_cast"></a>4.   dynamic_cast</h2><p>适用于我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。dynamic_cast在向下转换时有类型检测的功能，比static_cast更安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dynamic_cast</span>&lt;type*&gt;(e)<br><span class="hljs-built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)<br><span class="hljs-built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)<br></code></pre></td></tr></table></figure><p>上述形式中，e的类型应该是type的公有派生类、公有基类或就是type类型。</p><p>如果指针类型转换失败，结果为0，如果转换目标是引用类型并且失败了，抛出bad_cast异常  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络编程API</title>
    <link href="/2022/02/13/Blog2/"/>
    <url>/2022/02/13/Blog2/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux网络编程API"><a href="#Linux网络编程API" class="headerlink" title="Linux网络编程API"></a>Linux网络编程API</h1><ol><li><p>主机字节序和网络字节序</p><ul><li>主机字节序(小端字节序)：高位字节存储在高地址</li><li>网络字节序(大端字节序)：高位字节存储在低地址<br>   相关API：   <figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br> <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>通用socket地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span><br>&#123;<br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span><br>&#123;<br>    <span class="hljs-type">sa_family_t</span> sin_family; <span class="hljs-comment">//地址族：AF_INET</span><br>    <span class="hljs-type">u_int16_t</span> sin_port;     <span class="hljs-comment">//端口号，要用网络字节序表示</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> sin_addr;<span class="hljs-comment">//ipv4地址结构体</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span><br>&#123;<br>    <span class="hljs-type">u_int32_t</span> s_addr;   <span class="hljs-comment">//ipv4地址，要用网络字节序表示</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>所有专用socket地址类型的变量使用时都需要转化为通用socket地址类型sockaddr。</p></li><li><p>IP地址转换函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* strptr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cp, <span class="hljs-keyword">struct</span> in_addr* inp)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr in)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>socket通信API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-comment">/* 创建socket */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span></span>;<br><br><span class="hljs-comment">/* 命名socket */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* my_addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">/* 服务器监听socket */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span></span>;<br><br><span class="hljs-comment">/* 接受连接 */</span><br><span class="hljs-comment">/* accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">/* 客户端发起连接 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *serv_addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<br><br><span class="hljs-comment">/* 关闭连接 父进程和子进程中都应调用*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br></code></pre></td></tr></table></figure></li><li><p>TCP数据读写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span>, <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/2022/02/13/Blog3/"/>
    <url>/2022/02/13/Blog3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><ol><li>auto类型说明符</li></ol><ul><li>auto定义的变量必须有初始值</li><li>当引用被用作初始值时，真正参与初始化的其实是引用对象的值，此时编译器以引用对象的类型作为auto的类型</li><li>auto一般会忽略顶层const，底层const则会保留下来。如果希望推断出的类型是一个顶层const，需要明确指出<figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> e = &amp;ci;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> f = ci;<br></code></pre></td></tr></table></figure>e的类型为const int *, f为const int;</li><li>设一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。如果我们给初始值绑定了一个引用，则此时的常量就不是顶层常量了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">//g: const int</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">//error! 不能为非常量引用绑定字面值</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span> ; <span class="hljs-comment">// 可以为常量引用绑定字面值</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h1><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，并且必须用到常量表达式初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;      <span class="hljs-comment">//20是常量表达式</span><br><span class="hljs-keyword">constexpr</span> limit = mf + <span class="hljs-number">1</span>;   <span class="hljs-comment">//常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();  <span class="hljs-comment">//只有当size是一个constexpr函数时才是一条正确的声明语句</span><br></code></pre></td></tr></table></figure><hr><h2 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h2><p>对声明constexpr时用到的类型有所限制，就成为字面值类型（算术类型、引用和指针）</p><ul><li>一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象；</li><li>constexpr在指针声明中只对指针有效，与指针所指的对象无关。</li></ul><hr><h2 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h2><p>constexpr函数指能用于常量表达式的函数，需满足以下条件：</p><ul><li>函数的返回类型及所有形参的类型都得是字面值类型；</li><li>函数体中必须有且只有一条return语句；也可以有不执行任何操作的语句；</li><li>constexpr函数被隐式的指定为内联函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>();<br></code></pre></td></tr></table></figure></li><li>允许constexpr函数的返回值并非一个常量:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果以cnt是常量表达式，它的返回值也是常量表达式，反之则不然</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() *cnt;&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类的相关知识</title>
    <link href="/2022/02/13/Blog5/"/>
    <url>/2022/02/13/Blog5/</url>
    
    <content type="html"><![CDATA[<h1 id="类的特性"><a href="#类的特性" class="headerlink" title="类的特性"></a>类的特性</h1><h2 id="构造函数特性"><a href="#构造函数特性" class="headerlink" title="构造函数特性"></a>构造函数特性</h2><ol><li>构造函数不能被声明成const；</li><li>合成的默认构造函数将按照如下规则初始化数据成员：<ul><li>如果存在类内初始值，用它来初始化成员；</li><li>否则，默认初始化该成员。</li></ul></li><li>C++11中，可以在参数列表后加&#x3D;default要求编译器生成构造函数;</li><li>如果类包含有内置类型或复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数；</li><li>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数；</li><li>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（转换构造函数)；</li><li>只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复；</li></ol><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ol><li>类可以把普通函数、其他的类或其他类的成员函数定义成友元；</li><li>友元声明只能出现在类定义的内部，且友元不是类的成员也不受它所在区域访问控制级别的约束；</li><li>必须在友元声明之外再专门对函数进行一次声明；</li><li>我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）；</li><li>友元声明的作用是影响访问权限，它本身并非普通意义上的声明，这意味着：<ul><li>类和非成员函数的声明不是必须在他们的友元声明之前；</li><li>就算在类的内部定义该函数，也必须在类的外部提供相应的声音从而使得函数可见；</li></ul></li></ol><h2 id="const相关"><a href="#const相关" class="headerlink" title="const相关"></a>const相关</h2><ol><li>紧跟在参数列表后面的const表示this是一个指向常量的指针；</li><li>可以通过在变量中加mutable而在const成员函数内修改该变量；</li><li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用；</li></ol><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ol><li>成员函数中使用的名字按如下方式查找：<ul><li>首先在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑；</li><li>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑；</li><li>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找；</li></ul></li></ol><hr><h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数；</li><li>拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的；</li><li>标准库容器中，insert或push是拷贝初始化，emplace是直接初始化，效率更高；</li><li>拷贝初始化时，编辑器可能跳过拷贝&#x2F;移动构造函数，进行直接初始化，但拷贝&#x2F;移动构造函数必须是存在且可访问的。<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3></li></ul><ol><li>定义删除的函数<ul><li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的</li></ul></li><li>为了阻止友元和成员函数进行拷贝，将拷贝控制成员声明为private的，但并不定义他们。</li></ol><hr><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ol><li>返回非引用类型的函数，我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上；</li><li>变量是左值，我们不能将一个右值引用绑定到一个右值引用类型的变量上；但可以显示的将一个左值转换为对应的右值引用类型；<figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;     <span class="hljs-comment">//正确，字面常量是右值</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = rr1;    <span class="hljs-comment">//错误，表达式rr1是左值！</span><br><span class="hljs-type">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1); <span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure></li><li>我们额可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</li></ol><h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><ol><li>只有当一个类没有定义任何自己版本的拷贝控制成员（包括析构函数），且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符；</li><li>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认地被定义为删除的；</li><li>由于移动操作“窃取”资源，它通常不分配任何资源，因此不会抛出任何异常。不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept;</li><li>除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。</li></ol><h2 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h2><p>我们可以在一个右值上调用成员函数，我们可以强制左侧运算对象是一个左值。引用限定符应该跟在const限定符之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo&amp;) &amp; <span class="hljs-comment">//只能向可修改的左值赋值</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><ol><li><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> prot_mem;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sneaky</span> : <span class="hljs-keyword">public</span> Base&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;   <span class="hljs-comment">//能访问Sneaky:prot_mem</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;     <span class="hljs-comment">//不能访问Base::prot_mem</span><br>    <span class="hljs-type">int</span> j;                          <span class="hljs-comment">//private</span><br>&#125;<br><span class="hljs-comment">//正确：clobber能访问Sneaky对象的private和protected成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;S)</span> </span>&#123; s.j = s.prot_mem = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-comment">//错误：clobber不能访问Base的protected成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure></li><li><p>派生类向基类转换的可访问性：</p><p>派生类向基类的转换是否可访问由使用该转换的代码块定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p><ul><li>只有当D公有的地继承B时，用户代码才能使用派生类向积累的转换；</li><li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；</li><li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换。</li></ul><p><strong>对于代码中的某个给定节点来说，如果积累的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</strong></p></li><li><p>名字查找与继承：</p><p>假定我们调用p-&gt;mem(),则依次执行以下4个步骤：</p><ol><li>首先确定p的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型；</li><li>在p的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错；</li><li>一旦找到了mem，就进行常规的类型检查以确定对于当前找到的mem，本次调用是否合法；</li><li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：<ul><li>如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型；</li><li>反之，则编译器将产生一个常规函数调用。</li></ul></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
